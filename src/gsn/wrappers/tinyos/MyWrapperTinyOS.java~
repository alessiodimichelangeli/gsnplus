package gsn.wrappers.tinyos;

import gsn.beans.AddressBean;
import gsn.beans.DataField;
import gsn.wrappers.AbstractWrapper;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.tinyos.message.Message;
import net.tinyos.message.MessageListener;
import net.tinyos.message.MoteIF;
import net.tinyos.packet.BuildSource;
import net.tinyos.packet.PhoenixSource;

import org.apache.log4j.Logger;

//per eccezioni
import javax.naming.OperationNotSupportedException;
import java.io.*;
//

public class MyWrapperTinyOS extends AbstractWrapper implements net.tinyos.message.MessageListener {

	// regular expression clauses for finding the field names and their types from packet definition
  	private static final String NAME_PATTERN = "// Accessor methods for field: (\\w+)";
  	private static final String TYPE_PATTERN = "//\\s+Field type: (\\w+(\\[\\])?),";

	//private final DataField [] structure = new DataField[] {new DataField("counter","int","contatore msg")};
	private transient DataField [ ] outputStructureCache;
	
	
	// the interface to communicate with mote
  	private MoteIF moteIF;
  	private static HashMap<String, String> types;
  	// hashmap for storing the field name and its type
  	private HashMap<String, String> fields;
  	private HashMap<String, String> outputFields;
  	// arraylist for storing the field names in the correct order
  	private ArrayList<String> fieldsOrdered;
  	private ArrayList<String> outputFieldsOrdered;
	
	
	//private String source;
  	private String packetName="OscilloscopeMsg";
  	private String path="/home/alessio/gsn/src/gsn/wrappers/tinyos/";
  	private String classPackage="gsn.wrappers.tinyos";
  	
  	
  	// class and object variables used to extract data from packets using reflection
  	private Class<?> packetClass;
  	private Object packetObject;
	//
	
	private final transient Logger logger = Logger.getLogger( MyWrapperTinyOS.class );
	private int threadCounter = 0;
	
	//per gestire upload di version
	private int version;
	//
	
	
	public boolean initialize ( ) {
		AddressBean addressBean = getActiveAddressBean( );
		String host = addressBean.getPredicateValue( "host" ); // The ip of the machine running serial forwarder.
		
		System.out.println("********************************************");
		System.out.println("Indirizzo del SerialForwarder= "+host);		
		System.out.println("********************************************");
		
		if ( host == null || host.trim( ).length( ) == 0 ) {
			logger.warn( "The >host< parameter is missing from the RemoteWrapper wrapper." );
			return false; //initialization failed, the host name is not provided in the parameters.
		}
	
		int port; // The port of the machine running serial forwarder.
		String portRaw = addressBean.getPredicateValue( "port" );
	
		if ( portRaw == null || portRaw.trim( ).length( ) == 0 ){ 
			logger.warn( "The >port< parameter is missing from the RemoteWrapper wrapper." );
			return false;// initialization failed, the port no. is not provided in the parameters.
		} 
		
		try {
			port = Integer.parseInt( portRaw );
			if ( port > 65000 || port <= 0 ) throw new Exception( "Bad port No" + port );
			} 
		catch ( Exception e ) {
			logger.warn( "The >port< parameter is not a valid integer for the RemoteWrapper wrapper." );
			return false; // initialization failed, the port no. is not valid.
		}
		
		System.out.println("********************************************");
		System.out.println("Porta del SerialForwarder= "+port);		
		System.out.println("********************************************");
		
		
		if ( logger.isDebugEnabled( ) )
			logger.debug( "The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*" );
			
		setName( "TinyOS-My-Wrapper"+ ( ++threadCounter ) ) ;
		
		System.out.println("********************************************");
		System.out.println("The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*");		
		System.out.println("********************************************");
		
		try {
			PhoenixSource reader=BuildSource.makePhoenix( BuildSource.makeSF(host , port ) , null );
			reader.start( );
			moteIF = new MoteIF( reader ); 
		} catch ( Exception e ) {
			logger.error( e.getMessage( ) , e );
			return false; // Serial Forwarder client couldn't establish the connection.
		}	
		
		
		types = makeTypeMap();
		//////////////////////////////////////////////////////////////////////////////////////////////////
		try {
      			//packetClass = Class.forName(classPackage + "." + packetName);
      			packetClass= Class.forName("gsn.wrappers.tinyos.OscilloscopeMsg");
      
      			packetObject = packetClass.newInstance();
       
     			Message msg = (Message)packetObject;
      
      			moteIF.registerListener(msg, this);
    		}
    		catch (Exception e) {
      			logger.warn("Reading packet structure of " + packetName + " failed:", e);
      			return false;
    		} 
    		outputStructureCache = createOutputStructure(path + packetName + ".java");
    		if(outputStructureCache == null)
      			return false;
    		else {
      			logger.warn("TinyOS MIG wrapper identifed the following fields from the "+(path+packetName+".java"));
      		for (DataField df : outputStructureCache) 
        		logger.warn("\t FieldName: "+df.getName()+" ("+df.getType()+")");
    		}
			
		/////////////////////////////////////////////////////////////////////////////////////////////////
		
		System.out.println("********************************************");
		System.out.println("Init OK");		
		System.out.println("********************************************");
		
		
		return true; //initialization is successful.
	}
	
	/** Creates a HashMap, where key is the type in nesC and value is the type in GSN */
  	private static HashMap<String, String> makeTypeMap() {
    		HashMap<String, String> types = new HashMap<String, String>();
    		types.put("byte", "tinyint");
    		types.put("short", "smallint");
    		types.put("int", "integer");
    		types.put("long", "bigint");
    		types.put("byte[]", "tinyint");
    		types.put("short[]", "smallint");
    		types.put("int[]", "integer");
    		types.put("long[]", "bigint");
    		return types;
  	}
	
	/** Creates the output structure required for posting data to GSN
   	* Reads definition from a file, whose name is given as a parameter and
   	* uses regular expression 
   	*/
  	private DataField[] createOutputStructure(String filename) {
    		fields = new HashMap<String, String>();
    		fieldsOrdered = new ArrayList<String>();
    		outputFields = new HashMap<String, String>();
    		outputFieldsOrdered = new ArrayList<String>();
    		try {
      			BufferedReader input = new BufferedReader(new FileReader(filename));
      			String data;
      			
      			Pattern namePattern = Pattern.compile(NAME_PATTERN);
      			Pattern typePattern = Pattern.compile(TYPE_PATTERN);
      			Matcher nameMatcher;
      			Matcher typeMatcher;
      			String name = null;
      			String type = null;
      
      			// Name and type aren't on the same line, so we have to clear the
      			// variables only after both are read successfully.
      			// There is a possibility that this might cause problems if
      			// at some time the regular expressions don't match the correct
     	 		// lines.
      			// The names have to be put to a separate datastructure, which
      			// retains the order: if they were stored only to a hashmap, then
      			// later we wouldn't know in which order they would be and the
      			// values would be set to wrong sensor names.
      			
      			while((data = input.readLine()) != null) {
        			nameMatcher = namePattern.matcher(data);
        			typeMatcher = typePattern.matcher(data);
        
        			while(nameMatcher.find()) {
          				name = nameMatcher.group(1);
        			}
        			
        			while(typeMatcher.find()) {
          				type = typeMatcher.group(1);
        			}
        
        			if(name != null && type != null) {
          				if(type.contains("[]")) {
            					int i=0;
            					int size=0;
            					Method getArraySize = packetClass.getDeclaredMethod("numElements_" + name);
            					try {
              						size = (Integer) getArraySize.invoke(packetObject);
            					} 
            					catch (InvocationTargetException e) {
              						logger.error("Invocation of numElements_" + name + " failed: %s%n", e);
            					}
            					
            					for(i=0; i < size; i++) {
              						outputFieldsOrdered.add(name + i);
              						outputFields.put(name + i, type);
              						logger.debug("Adding " + name + i + " with type " + type);                            
            					}
            					
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					name = null;
            					type = null;                        
          				} 
          				else {
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					outputFieldsOrdered.add(name);
            					outputFields.put(name, type);
            					logger.debug("Adding " + name + " with type " + type);
            					name = null;
            					type = null;
          				}
        			}
      			}
      			
      			input.close();
      			
    		} 
    		catch (Exception e) {
      			logger.warn("File input error", e);
      			return null;
    		}
    
    		// create an array of DataTypes for returning
    		ArrayList<DataField> fieldsAL = new ArrayList<DataField>();
    		Iterator<String> it = outputFieldsOrdered.iterator();
   		while(it.hasNext()) {
      			String curName = it.next();
      			String curType = outputFields.get(curName);
      			fieldsAL.add(new DataField(curName.toUpperCase(), types.get(curType), curName));
    		}
    		
    		return fieldsAL.toArray(new DataField[] {} );
  	}
	
	
	
	
	public synchronized void finalize ( ) {
		moteIF.deregisterListener( new SensorScopeDataMsg( ) , this );
	}
	
	
	/** Implements net.tinyos.message.MessageListener.messageReceived
   	* Stores the received message to a buffer so that GSN can fetch the message
   	* from there whenever it wants.
   	*/
	public void messageReceived ( int toAddr , Message message ) {
		logger.debug("Received message");
    		System.out.println("*************************");
    		System.out.println("Messaggio ricevuto dal serial forwarder...");
   		
    		try {
      			Constructor<?> packetConstructor = packetClass.getDeclaredConstructor(Message.class, int.class, int.class);
      			if(message == null) {
        			logger.warn("Message was null!");
        			return;
      			}
      			packetObject = packetConstructor.newInstance(message, message.baseOffset(), message.dataLength());
    		} 
    		catch(NoSuchMethodException e) {
      			logger.error("Cannot create an instance of packet: constructor not found", e);
      			return;
    		} 
    		catch(InstantiationException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(IllegalAccessException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(InvocationTargetException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		}	
    
    		// The return values are always short, int or long.
    		// Here we don't have to mind about it as they are all serializable, and
    		// we can return an array of serializable-objects.
    		ArrayList<Serializable> retvals = new ArrayList<Serializable>();            
    		Method[] allMethods = packetClass.getDeclaredMethods();
    
    		for(String fieldName : fieldsOrdered) {
      			boolean isArray = checkArray(fieldName);
      			for (Method method : allMethods) {
        			String methodName = method.getName();
        			try {
          				if(methodName.equals("get_" + fieldName)) {
            					method.setAccessible(true);
            					Serializable value = (Serializable) method.invoke(packetObject);
            					if (logger.isDebugEnabled()) {
              						logger.debug("Using " + methodName);
              						logger.debug("Got: " + value.getClass().getCanonicalName());
            					}
            					if(isArray) {
              						for(int i=0; i < Array.getLength(value); i++) {
                						retvals.add((Serializable) Array.get(value, i));
              						}
            					} 
           					else {
              						retvals.add((Serializable) method.invoke(packetObject));
            					}
          				}
        			} 
        			catch (InvocationTargetException e) {
          				logger.error("Invocation of " + methodName + " failed: %s%n", e);
        			} 
        			catch (IllegalAccessException e) {
          				logger.error("Cannot access " + methodName, e);
        			}
      			}
    		}
    		
    		
    		//per gestire upload di version
    		version= Integer.parseInt(retvals.get(0).toString());
    		System.out.println("Version attuale= "+ version);
    		//
    		System.out.println("*************************");
    		postStreamElement( retvals.toArray(new Serializable[] {}) );
	
	
	}
	
	
	private boolean checkArray(String fieldName) {
    		String type = fields.get(fieldName);
    		if(type.contains("[]")) 
    			return true;
    		else 
    			return false;
  	}
	
	public DataField [] getOutputFormat ( ) { 
		return outputStructureCache;
	}
	
	public String getWrapperName(){
		return "My Wrapper TinyOS";
	}
	
	public void dispose ( ) {
    		threadCounter--;
  	}
  	
  	
  	 /** Overrides gsn.wrappers.AbstractWrapper.run
   	* Nothing to do, because the values are inserted to GSN whenever packets arrive.
   	*/
  	public void run ( ) {
  	}
  	
  	
  	/**
   	* Can be used by other classes which are extending this class to create elaborated communication such
   	* as send a packet back to the sensor network.
   	* @return
   	*/
  	protected MoteIF getMoteIF() {
    		return moteIF;
  	}
  	
  	
  	public boolean sendToWrapper(String action, String[] paramNames, Object[] paramValues) throws OperationNotSupportedException {
		try {
				System.out.println("*************************");
				System.out.println("Pronto per inviare messaggio...");
				 
				
				System.out.print(paramNames[0]+": ");
				System.out.println(paramValues[0]);
				
								
				String updatedIntervalString= paramValues[0].toString();
				int updatedInterval= Integer.parseInt(updatedIntervalString);
				
				
				
				OscilloscopeMsg omsg = new OscilloscopeMsg();
				
				
				
				version=version+1;
				
				
				System.out.print("Version: ");
				System.out.println(version);
				
				
				omsg.set_version(version);
    				omsg.set_interval(updatedInterval);
    				
        			moteIF.send(MoteIF.TOS_BCAST_ADDR, omsg);
   				
				
				
				//postStreamElement(new Serializable[] { updatedSwitcher });  
				
				
				
				//postStreamElement(new Serializable[] { Integer.parseInt(paramValues[0].toString()) }); 
				
				
				
				/*PrintWriter pw = new PrintWriter( "switcher" );
				pw.write( dataItem.toString( ) );
				pw.flush( );
				pw.close( );*/
				System.out.println("...messaggio inviato correttamente al serial forwarder!");
				System.out.println("*************************");
			
			return true;
		} catch ( IOException e ) {
			logger.warn( "OutputStream write error. " , e );
			return false;
		}
  }
  	
  	
  	

}







