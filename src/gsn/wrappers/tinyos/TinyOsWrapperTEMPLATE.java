/*
* File: src/gsn/wrappers/tinyos/TinyOsWrapperTEMPLATE.java
*
* @author Alessio Di Michelangeli
*
*/


//THIS WRAPPER IS A TINY OS TEMPLATE WRAPPER.
//There is the possibility to choose if you want to read the message structure, as shown in the 
//TinyOsMessage (generated via mig) or simply changes it as you want. 
//It can manage the message upload from the GSN SERVER.


/********************************************	README	********************************************

Please remember, before compile gsn project (via ant gsn command), generate the related tiny os 
message file (via mig), edits it writing the line: "package gsn.wrappers.tinyos;" on top and finally
paste the edited file on the src/gsn/wrappers/tinyos folder.

****************************************************************************************************/

package gsn.wrappers.tinyos;

import gsn.beans.AddressBean;
import gsn.beans.DataField;
import gsn.wrappers.AbstractWrapper;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.tinyos.message.Message;
import net.tinyos.message.MessageListener;
import net.tinyos.message.MoteIF;
import net.tinyos.packet.BuildSource;
import net.tinyos.packet.PhoenixSource;

import org.apache.log4j.Logger;

//to manage extension
import javax.naming.OperationNotSupportedException;
import java.io.*;
//

public class TinyOsWrapperTEMPLATE extends AbstractWrapper implements net.tinyos.message.MessageListener {

	/*N.B. if you want to get a different output structure you have to define a new DataField[] collection, otherwise the output structure will be the message structure (from tinyos) itself.
	
	private DataField[] collectionOutput = new DataField[] { new DataField(..., ..., ...), ... };

	*/

	private Message msg;
	
	//this structure will contain the message structure from tinyos.
	private transient DataField [ ] outputStructureCache;


	// regular expression clauses for finding the field names and their types from packet definition
  	private static final String NAME_PATTERN = "// Accessor methods for field: (\\w+)";
  	private static final String TYPE_PATTERN = "//\\s+Field type: (\\w+(\\[\\])?),";
	
	
	// the interface to communicate with mote
  	private MoteIF moteIF;
  	private static HashMap<String, String> types;
  	// hashmap for storing the field name and its type
  	private HashMap<String, String> fields;
  	private HashMap<String, String> outputFields;
  	// arraylist for storing the field names in the correct order
  	private ArrayList<String> fieldsOrdered;
  	private ArrayList<String> outputFieldsOrdered;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/*INIT OF CODE TO EDIT
	
		You have to edit the follow code if you have changed the tinyos app.
		More precisely when you change the message sended by the tinyos mote to the serial forwarder,
		you have to re-generate the message via mig 
		(mig -target=null -java-classname="YOUR_TINYOS_APP"Msg java "YOUR_TINYOS_APP".h "YOUR_TINYOS_APP" -o > "YOUR_TINYOS_APP"Msg.java).
		Edit the generated file writing this line: "package gsn.wrappers.tinyos;" on the top of the file
		and put it into this folder: "YOUR_HOME"/gsn/src/gsn/wrappers/tinyos.
		
	
	*/
		
	//private String source;
	
	//YOU HAVE TO EDIT THIS
  	private String packetName="TinyOsMsg NAME"; //this must be the name of the msg file generated by mig 
  	//
  	
  	private String path="/YOURHOME/YOURNAME/GSNDIR/src/gsn/wrappers/tinyos/"; //this must be the path of the file generated by mig
  	private String classPackage="gsn.wrappers.tinyos"; 
  	
  	/*END OF CODE TO EDIT*/
  	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	
  	
  	
  	
  	// class and object variables used to extract data from packets using reflection
  	private Class<?> packetClass;
  	private Object packetObject;
	//
	
	private final transient Logger logger = Logger.getLogger( TinyOsWrapperTEMPLATE.class );
	private int threadCounter = 0;
	
	
	
	// initialization
	public boolean initialize ( ) {
		AddressBean addressBean = getActiveAddressBean( );
		String host = addressBean.getPredicateValue( "host" ); // The ip of the machine running serial forwarder.
		
		System.out.println("********************************************");
		System.out.println("Address of the SerialForwarder= "+host);		
		System.out.println("********************************************");
		
		if ( host == null || host.trim( ).length( ) == 0 ) {
			logger.warn( "The >host< parameter is missing from the RemoteWrapper wrapper." );
			return false; //initialization failed, the host name is not provided in the parameters.
		}
	
		int port; // The port of the machine running serial forwarder.
		String portRaw = addressBean.getPredicateValue( "port" );
	
		if ( portRaw == null || portRaw.trim( ).length( ) == 0 ){ 
			logger.warn( "The >port< parameter is missing from the RemoteWrapper wrapper." );
			return false;// initialization failed, the port no. is not provided in the parameters.
		} 
		
		try {
			port = Integer.parseInt( portRaw );
			if ( port > 65000 || port <= 0 ) throw new Exception( "Bad port No" + port );
			} 
		catch ( Exception e ) {
			logger.warn( "The >port< parameter is not a valid integer for the RemoteWrapper wrapper." );
			return false; // initialization failed, the port no. is not valid.
		}
		
		System.out.println("********************************************");
		System.out.println("Port of the SerialForwarder= "+port);		
		System.out.println("********************************************");
		
		
		if ( logger.isDebugEnabled( ) )
			logger.debug( "The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*" );
			
		setName( "TinyOsWrapperTEMPLATE"+ ( ++threadCounter ) ) ;
		
		System.out.println("********************************************");
		System.out.println("The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*");		
		System.out.println("********************************************");
		
		try {
			PhoenixSource reader=BuildSource.makePhoenix( BuildSource.makeSF(host , port ) , null );
			reader.start( );
			moteIF = new MoteIF( reader ); 
		} catch ( Exception e ) {
			logger.error( e.getMessage( ) , e );
			return false; // Serial Forwarder client couldn't establish the connection.
		}	
		
		
		types = makeTypeMap();
		//////////////////////////////////////////////////////////////////////////////////////////////////
		try {
      			packetClass = Class.forName(classPackage + "." + packetName);
      			
      			packetObject = packetClass.newInstance();
       
     			msg = (Message)packetObject;
      
      			moteIF.registerListener(msg, this);
    		}
    		catch (Exception e) {
      			logger.warn("Reading packet structure of " + packetName + " failed:", e);
      			return false;
    		} 
    		outputStructureCache = createOutputStructure(path + packetName + ".java");
    		if(outputStructureCache == null)
      			return false;
    		else {
      			logger.warn("TinyOS TEMPLATE wrapper identifed the following fields from the "+(path+packetName+".java"));
      		for (DataField df : outputStructureCache) 
        		//logger.warn("\t FieldName: "+df.getName()+" ("+df.getType()+")");
        		System.out.println("\t FieldName: "+df.getName()+" ("+df.getType()+")");
    		}
			
		/////////////////////////////////////////////////////////////////////////////////////////////////
		
		System.out.println("********************************************");
		System.out.println("Init OK");		
		System.out.println("********************************************");
		
		
		return true; //initialization is successful.
	}
	
	
	
	/** Creates a HashMap, where key is the type in nesC and value is the type in GSN */
  	private static HashMap<String, String> makeTypeMap() {
    		HashMap<String, String> types = new HashMap<String, String>();
    		types.put("byte", "tinyint");
    		types.put("short", "smallint");
    		types.put("int", "integer");
    		types.put("long", "bigint");
    		types.put("byte[]", "tinyint");
    		types.put("short[]", "smallint");
    		types.put("int[]", "integer");
    		types.put("long[]", "bigint");
    		return types;
  	}
	
	
	
	/** Creates the output structure required for posting data to GSN
   	* Reads definition from a file, whose name is given as a parameter and
   	* uses regular expression 
   	*/
   	//THIS STRUCTURE HAS THE SAME FIELD OF THE TINYOS MSG
  	private DataField[] createOutputStructure(String filename) {
    		fields = new HashMap<String, String>();
    		fieldsOrdered = new ArrayList<String>();
    		outputFields = new HashMap<String, String>();
    		outputFieldsOrdered = new ArrayList<String>();
    		try {
      			BufferedReader input = new BufferedReader(new FileReader(filename));
      			String data;
      			
      			Pattern namePattern = Pattern.compile(NAME_PATTERN);
      			Pattern typePattern = Pattern.compile(TYPE_PATTERN);
      			Matcher nameMatcher;
      			Matcher typeMatcher;
      			String name = null;
      			String type = null;
      
      			// Name and type aren't on the same line, so we have to clear the
      			// variables only after both are read successfully.
      			// There is a possibility that this might cause problems if
      			// at some time the regular expressions don't match the correct
     	 		// lines.
      			// The names have to be put to a separate datastructure, which
      			// retains the order: if they were stored only to a hashmap, then
      			// later we wouldn't know in which order they would be and the
      			// values would be set to wrong sensor names.
      			
      			while((data = input.readLine()) != null) {
        			nameMatcher = namePattern.matcher(data);
        			typeMatcher = typePattern.matcher(data);
        
        			while(nameMatcher.find()) {
          				name = nameMatcher.group(1);
        			}
        			
        			while(typeMatcher.find()) {
          				type = typeMatcher.group(1);
        			}
        
        			if(name != null && type != null) {
          				if(type.contains("[]")) {
            					int i=0;
            					int size=0;
            					Method getArraySize = packetClass.getDeclaredMethod("numElements_" + name);
            					try {
              						size = (Integer) getArraySize.invoke(packetObject);
            					} 
            					catch (InvocationTargetException e) {
              						logger.error("Invocation of numElements_" + name + " failed: %s%n", e);
            					}
            					
            					for(i=0; i < size; i++) {
              						outputFieldsOrdered.add(name + i);
              						outputFields.put(name + i, type);
              						logger.debug("Adding " + name + i + " with type " + type);                            
            					}
            					
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					name = null;
            					type = null;                        
          				} 
          				else {
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					outputFieldsOrdered.add(name);
            					outputFields.put(name, type);
            					logger.debug("Adding " + name + " with type " + type);
            					name = null;
            					type = null;
          				}
        			}
      			}
      			
      			input.close();
      			
    		} 
    		catch (Exception e) {
      			logger.warn("File input error", e);
      			return null;
    		}
    
    		// create an array of DataTypes for returning
    		ArrayList<DataField> fieldsAL = new ArrayList<DataField>();
    		Iterator<String> it = outputFieldsOrdered.iterator();
   		while(it.hasNext()) {
      			String curName = it.next();
      			String curType = outputFields.get(curName);
      			fieldsAL.add(new DataField(curName.toUpperCase(), types.get(curType), curName));
    		}
    		
    		
    		return fieldsAL.toArray(new DataField[] {} );
  	}
	
	
	
	public synchronized void finalize ( ) {
		moteIF.deregisterListener( msg , this );
	}
	
	
	/** Implements net.tinyos.message.MessageListener.messageReceived
   	* Stores the received message to a buffer so that GSN can fetch the message
   	* from there whenever it wants.
   	*/
	public void messageReceived ( int toAddr , Message message ) {
		logger.debug("Received message");
    		System.out.println("*************************");
    		System.out.println("Ready to process message received by Serial Forwarder...");
   		
    		try {
      			Constructor<?> packetConstructor = packetClass.getDeclaredConstructor(Message.class, int.class, int.class);
      			if(message == null) {
        			logger.warn("Message was null!");
        			return;
      			}
      			packetObject = packetConstructor.newInstance(message, message.baseOffset(), message.dataLength());
    		} 
    		catch(NoSuchMethodException e) {
      			logger.error("Cannot create an instance of packet: constructor not found", e);
      			return;
    		} 
    		catch(InstantiationException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(IllegalAccessException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(InvocationTargetException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		}	
    
    		// The return values are always short, int or long.
    		// Here we don't have to mind about it as they are all serializable, and
    		// we can return an array of serializable-objects.
    		ArrayList<Serializable> retvals = new ArrayList<Serializable>();            
    		Method[] allMethods = packetClass.getDeclaredMethods();
    
    		for(String fieldName : fieldsOrdered) {
      			boolean isArray = checkArray(fieldName);
      			for (Method method : allMethods) {
        			String methodName = method.getName();
        			try {
          				if(methodName.equals("get_" + fieldName)) {
            					method.setAccessible(true);
            					Serializable value = (Serializable) method.invoke(packetObject);
            					if (logger.isDebugEnabled()) {
              						logger.debug("Using " + methodName);
              						logger.debug("Got: " + value.getClass().getCanonicalName());
            					}
            					if(isArray) {
              						for(int i=0; i < Array.getLength(value); i++) {
                						retvals.add((Serializable) Array.get(value, i));
              						}
            					} 
           					else {
              						retvals.add((Serializable) method.invoke(packetObject));
            					}
          				}
        			} 
        			catch (InvocationTargetException e) {
          				logger.error("Invocation of " + methodName + " failed: %s%n", e);
        			} 
        			catch (IllegalAccessException e) {
          				logger.error("Cannot access " + methodName, e);
        			}
      			}
    		}
    		 		
    		System.out.println("...message correctly received!");    		
    		System.out.println("*************************");
    		
    		//post data to gsn
    		postStreamElement( retvals.toArray(new Serializable[] {}) );
    		
    		/*********************IF YOU CHANGED THE OUTPUT STRUCTURE READ THE FOLLOWING TEXT*********************/
    		/*In particular is necessary to compile the data field collectionoutput, as is written in the xml virtual sensor 
    		  related file. To make this possible we have to call the poststream element method with the same fields of the 	
    		  collectionoutput variable. 											*/
  
  		/*Please note that retvals.get("index number").toString()) returns the value of the message TelosbSensorReadingMsg
  			
  			0 --> first field
  			1 --> second field
  			2 --> ...
  			...
  		
  		FOR EXAMPLE IF YOU WANT TO SHOW A MODIFIED FIRST FIELD VERSION INTO GSN:
  		
  		int firstField= Integer.parseInt(retvals.get(0).toString());
  		double outputFirstField= firstField / 2;
  		
  		//the method arguments must be  as shown in collectionoutput variable 
  		postStreamElement(new Serializable[] { outputFirstField });
  		
  		*/ 
	
	}
	
	
	private boolean checkArray(String fieldName) {
    		String type = fields.get(fieldName);
    		if(type.contains("[]")) 
    			return true;
    		else 
    			return false;
  	}
	
	/*************************************************************************************************************/
	// returned varible must have the same structure of xml virtual sensor file and data field variable.
	public DataField [] getOutputFormat ( ) { 
		
		return outputStructureCache;
		
		/*********************IF YOU CHANGED THE OUTPUT STRUCTURE READ THE FOLLOWING TEXT*********************/
		/* you have to use this return instruction
		return collectionOutput;*/
	}
	/*************************************************************************************************************/
	
		
	public String getWrapperName(){
		return "TinyOsWrapperTEMPLATE";
	}
	
	public void dispose ( ) {
    		threadCounter--;
  	}
  	
  	
  	 /** Overrides gsn.wrappers.AbstractWrapper.run
   	* Nothing to do, because the values are inserted to GSN whenever packets arrive.
   	*/
  	public void run ( ) {
  	}
  	
  	
  	/**
   	* Can be used by other classes which are extending this class to create elaborated communication such
   	* as send a packet back to the sensor network.
   	* @return
   	*/
  	protected MoteIF getMoteIF() {
    		return moteIF;
  	}
  	
  	
  	
  	/***************************************************************************************************************/
  	/**********************IF YOU WANT TO ADD THE POSSIBILITY TO UPLOAD DATA FROM GSN TO TINYOS*********************/
  	/*
  	public boolean sendToWrapper(String action, String[] paramNames, Object[] paramValues) throws OperationNotSupportedException {
		   try 	{
				/*RELATED TO THE XML VIRTUAL SENSOR FILE, THE PARAMETERS ARE AS FOLLOW
				
				//action= field name of command-tag into web-input-tag.
				//paramNames= field name of field-tag in command-tag. 
				//paramValues= value of paramName.
				
				*/
				/*
				
				System.out.println("*************************");
				System.out.println("Ready to send message...");
				System.out.println(action); 
				
				YOUR_TINYOS_APP_MSG yourMsg= new YOUR_TINYOS_APP_MSG(); 
				
				FOR EXAMPLE IF YOU WANT TO MODIFY THE FIRST FIELD FROM GSN SERVER AND UPLOAD IT OVER THE TINYOS NETWORK:
				
				if (action.equals("YOUR ACTION 1")){	
					//it takes the value from the web. Only one parameter for this function.
					System.out.print(paramNames[0]+": ");
					System.out.println(paramValues[0]);	
					//to manage first field upload			
					String updatedFirstFieldString= paramValues[0].toString();
					System.out.print("New First Field: ");
					System.out.println(updatedFirstFieldString);
					int updatedFirstField= Integer.parseInt(updatedFirstFieldString);
		
					//set the first field to the sample message
					yourMsg.set_field(updatedFirstField);	
				}
				
				
				if (action.equals("YOUR ACTION 2")){	
					...
    					...	    						
				}
				...
    				
    				//Finally send the message with the updated data via broadcast to the motes
   				moteIF.send(MoteIF.TOS_BCAST_ADDR, tsrMsg);
   				//
   				
				
				System.out.println("...message correctly sended to Serial Forwarder!");
				System.out.println("*************************");
			
				return true;
			} 
			catch ( IOException e ) {
				logger.warn( "OutputStream write error. " , e );
				return false;
			}
  	}
  	*/
  	
  	

}

