/*
* File: src/gsn/wrappers/tinyos/TelosbSensorReadingWrapper.java
*
* @author Alessio Di Michelangeli
*
*/


//THIS WRAPPER IS SUITABLE ONLY FOR THE TELOSB SENSOR.
//It reads datas from the TelosbSensorReadingMsg, it edits them to calculate the real sensor value,
//and finally it sends them to the GSN SERVER. 
//It can manage the message upload from the GSN SERVER.
//In particular, it can upload commands like:
//	- change interval value
//	- turn on red led
//	- turn off red led
//	- blink red led


/********************************************	README	********************************************

Please remember, before compile gsn project (via ant gsn command), generate the related tiny os 
message file (via mig), edits it writing the line: "package gsn.wrappers.tinyos;" on top and finally
paste the edited file on the src/gsn/wrappers/tinyos folder.

****************************************************************************************************/

package gsn.wrappers.tinyos;

import gsn.beans.AddressBean;
import gsn.beans.DataField;
import gsn.wrappers.AbstractWrapper;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.tinyos.message.Message;
import net.tinyos.message.MessageListener;
import net.tinyos.message.MoteIF;
import net.tinyos.packet.BuildSource;
import net.tinyos.packet.PhoenixSource;

import org.apache.log4j.Logger;

//to manage extension
import javax.naming.OperationNotSupportedException;
import java.io.*;
//

public class TelosbSensorReadingWrapper extends AbstractWrapper implements net.tinyos.message.MessageListener {


	// this is the output structure
	private DataField[] collectionOutput = new DataField[] { new DataField("id", "int", "Sensor id."), new DataField("version", "int", "Interval version"), new DataField("interval", "int", "Sampling interval."), new DataField("count", "int", "Counter."), new DataField("temperature_avg", "double", "Average temperature"), new DataField("humidity_avg", "double", "Average humitidy"), new DataField("hum_avg_temp_comp", "double", "Average humitidy with temp comp."), new DataField("luminance_avg", "double", "Average luminance."), new DataField("photo_avg", "double", "Average photo sensor.")  };

	// regular expression clauses for finding the field names and their types from packet definition
  	private static final String NAME_PATTERN = "// Accessor methods for field: (\\w+)";
  	private static final String TYPE_PATTERN = "//\\s+Field type: (\\w+(\\[\\])?),";

	private transient DataField [ ] outputStructureCache;
	private Message msg;
	
	// the interface to communicate with mote
  	private MoteIF moteIF;
  	private static HashMap<String, String> types;
  	// hashmap for storing the field name and its type
  	private HashMap<String, String> fields;
  	private HashMap<String, String> outputFields;
  	// arraylist for storing the field names in the correct order
  	private ArrayList<String> fieldsOrdered;
  	private ArrayList<String> outputFieldsOrdered;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/*INIT OF CODE TO EDIT
	
		You have to edit the follow code if you have changed the tinyos app.
		More precisely when you change the message sended by the tinyos mote to the serial forwarder,
		you have to re-generate the message via mig 
		(mig -target=null -java-classname="YOUR_TINYOS_APP"Msg java "YOUR_TINYOS_APP".h "YOUR_TINYOS_APP" -o > "YOUR_TINYOS_APP"Msg.java).
		Edit the generated file writing this line: "package gsn.wrappers.tinyos;" on the top of the file
		and put it into this folder: "YOUR_HOME"/gsn/src/gsn/wrappers/tinyos.
		
	*/
		
	
	//YOU HAVE TO EDIT THIS
  	private String packetName="TelosbSensorReadingMsg"; //this is the name of the file generated by mig 
  	//
  	
  	private String path="/home/alessio/gsn/src/gsn/wrappers/tinyos/"; //this is the path of the file generated by mig
  	private String classPackage="gsn.wrappers.tinyos"; 
  	
  	/*END OF CODE TO EDIT*/
  	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	
  	
  	
  	
  	// class and object variables used to extract data from packets using reflection
  	private Class<?> packetClass;
  	private Object packetObject;
	//
	
	private final transient Logger logger = Logger.getLogger( TelosbSensorReadingWrapper.class );
	private int threadCounter = 0;
	
	
	
	//to manage upload of version
	private int version;
	//
	
	
	public boolean initialize ( ) {
		AddressBean addressBean = getActiveAddressBean( );
		String host = addressBean.getPredicateValue( "host" ); // The ip of the machine running serial forwarder.
		
		System.out.println("********************************************");
		System.out.println("Address of the SerialForwarder= "+host);		
		System.out.println("********************************************");
		
		if ( host == null || host.trim( ).length( ) == 0 ) {
			logger.warn( "The >host< parameter is missing from the RemoteWrapper wrapper." );
			return false; //initialization failed, the host name is not provided in the parameters.
		}
	
		int port; // The port of the machine running serial forwarder.
		String portRaw = addressBean.getPredicateValue( "port" );
	
		if ( portRaw == null || portRaw.trim( ).length( ) == 0 ){ 
			logger.warn( "The >port< parameter is missing from the RemoteWrapper wrapper." );
			return false;// initialization failed, the port no. is not provided in the parameters.
		} 
		
		try {
			port = Integer.parseInt( portRaw );
			if ( port > 65000 || port <= 0 ) throw new Exception( "Bad port No" + port );
			} 
		catch ( Exception e ) {
			logger.warn( "The >port< parameter is not a valid integer for the RemoteWrapper wrapper." );
			return false; // initialization failed, the port no. is not valid.
		}
		
		System.out.println("********************************************");
		System.out.println("Port of the SerialForwarder= "+port);		
		System.out.println("********************************************");
		
		
		if ( logger.isDebugEnabled( ) )
			logger.debug( "The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*" );
			
		setName( "TelosbSensorReadingWrapper"+ ( ++threadCounter ) ) ;
		
		System.out.println("********************************************");
		System.out.println("The SFWrapperDS connects to the Serial Forwarderinterface at *" + host + ":" + port + "*");		
		System.out.println("********************************************");
		
		try {
			PhoenixSource reader=BuildSource.makePhoenix( BuildSource.makeSF(host , port ) , null );
			reader.start( );
			moteIF = new MoteIF( reader ); 
		} catch ( Exception e ) {
			logger.error( e.getMessage( ) , e );
			return false; // Serial Forwarder client couldn't establish the connection.
		}	
		
		
		types = makeTypeMap();
		//////////////////////////////////////////////////////////////////////////////////////////////////
		try {
      			packetClass = Class.forName(classPackage + "." + packetName);
      			
      			packetObject = packetClass.newInstance();
       
     			msg = (Message)packetObject;
      
      			moteIF.registerListener(msg, this);
    		}
    		catch (Exception e) {
      			logger.warn("Reading packet structure of " + packetName + " failed:", e);
      			return false;
    		} 
    		outputStructureCache = createOutputStructure(path + packetName + ".java");
    		if(outputStructureCache == null)
      			return false;
    		else {
      			logger.warn("TelosbSensorReadingWrapper identifed the following fields from the "+(path+packetName+".java"));
      		for (DataField df : outputStructureCache) 
        		//logger.warn("\t FieldName: "+df.getName()+" ("+df.getType()+")");
        		System.out.println("\t FieldName: "+df.getName()+" ("+df.getType()+")");
    		}
			
		/////////////////////////////////////////////////////////////////////////////////////////////////
		
		System.out.println("********************************************");
		System.out.println("Init OK");		
		System.out.println("********************************************");
		
		
		return true; //initialization is successful.
	}
	
	
	
	/** Creates a HashMap, where key is the type in nesC and value is the type in GSN */
  	private static HashMap<String, String> makeTypeMap() {
    		HashMap<String, String> types = new HashMap<String, String>();
    		types.put("byte", "tinyint");
    		types.put("short", "smallint");
    		types.put("int", "integer");
    		types.put("long", "bigint");
    		types.put("byte[]", "tinyint");
    		types.put("short[]", "smallint");
    		types.put("int[]", "integer");
    		types.put("long[]", "bigint");
    		return types;
  	}
	
	
	
	/** Creates the output structure required for posting data to GSN
   	* Reads definition from a file, whose name is given as a parameter and
   	* uses regular expression 
   	*/
  	private DataField[] createOutputStructure(String filename) {
    		fields = new HashMap<String, String>();
    		fieldsOrdered = new ArrayList<String>();
    		outputFields = new HashMap<String, String>();
    		outputFieldsOrdered = new ArrayList<String>();
    		try {
      			BufferedReader input = new BufferedReader(new FileReader(filename));
      			String data;
      			
      			Pattern namePattern = Pattern.compile(NAME_PATTERN);
      			Pattern typePattern = Pattern.compile(TYPE_PATTERN);
      			Matcher nameMatcher;
      			Matcher typeMatcher;
      			String name = null;
      			String type = null;
      
      			// Name and type aren't on the same line, so we have to clear the
      			// variables only after both are read successfully.
      			// There is a possibility that this might cause problems if
      			// at some time the regular expressions don't match the correct
     	 		// lines.
      			// The names have to be put to a separate datastructure, which
      			// retains the order: if they were stored only to a hashmap, then
      			// later we wouldn't know in which order they would be and the
      			// values would be set to wrong sensor names.
      			
      			while((data = input.readLine()) != null) {
        			nameMatcher = namePattern.matcher(data);
        			typeMatcher = typePattern.matcher(data);
        
        			while(nameMatcher.find()) {
          				name = nameMatcher.group(1);
        			}
        			
        			while(typeMatcher.find()) {
          				type = typeMatcher.group(1);
        			}
        
        			if(name != null && type != null) {
          				if(type.contains("[]")) {
            					int i=0;
            					int size=0;
            					Method getArraySize = packetClass.getDeclaredMethod("numElements_" + name);
            					try {
              						size = (Integer) getArraySize.invoke(packetObject);
            					} 
            					catch (InvocationTargetException e) {
              						logger.error("Invocation of numElements_" + name + " failed: %s%n", e);
            					}
            					
            					for(i=0; i < size; i++) {
              						outputFieldsOrdered.add(name + i);
              						outputFields.put(name + i, type);
              						logger.debug("Adding " + name + i + " with type " + type);                            
            					}
            					
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					name = null;
            					type = null;                        
          				} 
          				else {
            					fieldsOrdered.add(name);
            					fields.put(name, type);
            					outputFieldsOrdered.add(name);
            					outputFields.put(name, type);
            					logger.debug("Adding " + name + " with type " + type);
            					name = null;
            					type = null;
          				}
        			}
      			}
      			
      			input.close();
      			
    		} 
    		catch (Exception e) {
      			logger.warn("File input error", e);
      			return null;
    		}
    
    		// create an array of DataTypes for returning
    		ArrayList<DataField> fieldsAL = new ArrayList<DataField>();
    		Iterator<String> it = outputFieldsOrdered.iterator();
   		while(it.hasNext()) {
      			String curName = it.next();
      			String curType = outputFields.get(curName);
      			fieldsAL.add(new DataField(curName.toUpperCase(), types.get(curType), curName));
    		}
    
    		
    		return fieldsAL.toArray(new DataField[] {} );
    		
  	}
	
	
	
	
	public synchronized void finalize ( ) {
		moteIF.deregisterListener( msg , this );
	}
	
	
	/** Implements net.tinyos.message.MessageListener.messageReceived
   	* Stores the received message to a buffer so that GSN can fetch the message
   	* from there whenever it wants.
   	*/
	public void messageReceived ( int toAddr , Message message ) {
		logger.debug("Received message");
    		System.out.println("*************************");
    		System.out.println("Ready to process message received by Serial Forwarder...");
   		
    		try {
      			Constructor<?> packetConstructor = packetClass.getDeclaredConstructor(Message.class, int.class, int.class);
      			if(message == null) {
        			logger.warn("Message was null!");
        			return;
      			}
      			packetObject = packetConstructor.newInstance(message, message.baseOffset(), message.dataLength());
    		} 
    		catch(NoSuchMethodException e) {
      			logger.error("Cannot create an instance of packet: constructor not found", e);
      			return;
    		} 
    		catch(InstantiationException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(IllegalAccessException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		} catch(InvocationTargetException e) {
      			logger.error("Cannot create an instance of packet", e);
      			return;
    		}	
    
    		// The return values are always short, int or long.
    		// Here we don't have to mind about it as they are all serializable, and
    		// we can return an array of serializable-objects.
    		ArrayList<Serializable> retvals = new ArrayList<Serializable>();            
    		Method[] allMethods = packetClass.getDeclaredMethods();
    
    		for(String fieldName : fieldsOrdered) {
      			boolean isArray = checkArray(fieldName);
      			for (Method method : allMethods) {
        			String methodName = method.getName();
        			try {
          				if(methodName.equals("get_" + fieldName)) {
            					method.setAccessible(true);
            					Serializable value = (Serializable) method.invoke(packetObject);
            					if (logger.isDebugEnabled()) {
              						logger.debug("Using " + methodName);
              						logger.debug("Got: " + value.getClass().getCanonicalName());
            					}
            					if(isArray) {
              						for(int i=0; i < Array.getLength(value); i++) {
                						retvals.add((Serializable) Array.get(value, i));
              						}
            					} 
           					else {
              						retvals.add((Serializable) method.invoke(packetObject));
            					}
          				}
        			} 
        			catch (InvocationTargetException e) {
          				logger.error("Invocation of " + methodName + " failed: %s%n", e);
        			} 
        			catch (IllegalAccessException e) {
          				logger.error("Cannot access " + methodName, e);
        			}
      			}
    		}
    		
    		
    		//DEBUG STUFF: to understand upload of version
    		version= Integer.parseInt(retvals.get(0).toString());
    		System.out.println("Version= "+ version);
    		//
    		
    		//DEBUG STUFF: to understand id
    		System.out.println("ID= "+ Integer.parseInt(retvals.get(2).toString()));
    		//
    		
    		System.out.println("...message correctly received!");    		
    		System.out.println("*************************");

    		
    		/*********************THE FOLLOWING PART IS RELETAD TO HOW TO PRESENT DATA TO THE GSN SERVER*********************/
    		/*In particular is necessary to compile the data field collectionoutput, as is written in the xml virtual sensor 
    		  related file. To make this possible we have to call the poststream element method with the same fields of the 	
    		  collectionoutput variable. 											*/
  
  		/*Please note that retvals.get("index number").toString()) returns the value of the message TelosbSensorReadingMsg
  			
  			0 --> version
  			1 --> interval
  			2 --> id
  			3 --> count
  			4 --> webCommandLed (NOT NECESSARY)
  			5 --> temp first value
  			6 --> temp sencod velue
  			7 --> hum first value
  			8 --> hum second value
  			9 --> lum first value
  			10--> lum second value
  			11--> photo first value
  			12--> photo second value
  		
  		*/ 
  		
    		int interval=Integer.parseInt(retvals.get(1).toString());	
    		int id=Integer.parseInt(retvals.get(2).toString());
    		int count=Integer.parseInt(retvals.get(3).toString());
    		//please note that version is already taken
    		
    		
    		/**********TEMPERATURE**********/
    		//catch the temperature signals from the telosb sensor and convert them into centigrade values
    		int temp0_signal= Integer.parseInt(retvals.get(5).toString());
    		int temp1_signal= Integer.parseInt(retvals.get(6).toString());
    		double temp0= -39.6 + (0.01 * temp0_signal);
    		double temp1= -39.6 + (0.01 * temp1_signal);
    		//calibration of temperature sensor
    		temp0= temp0 - 2;
    		temp1= temp1 - 2;
    		//end of calibration
    		//take the average
    		double temp_avg= (temp0 + temp1)/2;
    		//only two numbers after the dot
    		temp_avg = Math.floor(temp_avg * 100) / 100;
    		//end of catch the temperature
    		/*******************************/
    		
    		
    		/**********RELATIVE HUMIDITY**********/
    		//catch the humidity signals from the telosb sensor and convert them into readeble values
    		int hum0_signal= Integer.parseInt(retvals.get(7).toString());
    		int hum1_signal= Integer.parseInt(retvals.get(8).toString());
    		//double hum0= -2.0468 + (0.0367*hum0_signal) - 0.0000015955*Math.pow(hum0_signal,2.0);
    		//double hum1= -2.0468 + (0.0367*hum1_signal) - 0.0000015955*Math.pow(hum1_signal,2.0);
    		double hum0= (-4.0 +0.0405*(hum0_signal))+(-0.0000028*Math.pow(hum0_signal,2.0));
    		double hum1= (-4.0 +0.0405*(hum1_signal))+(-0.0000028*Math.pow(hum1_signal,2.0));
    		//take the average
    		double hum_avg= (hum0 + hum1)/2;
    		//only two numbers after the dot
    		hum_avg= Math.floor(hum_avg * 100) / 100;
    		//end of catch the humidity
    		/*************************************/
    		
    		
    		/**********HUMIDITY TEMP COMPENSATION**********/
    		//catch the humidity signals from the telosb sensor and convert them into readeble values
    		double hum0_temp_comp= (temp_avg - 25) * (0.01 + 0.00008 * hum0_signal) + hum0 ;
    		double hum1_temp_comp= (temp_avg - 25) * (0.01 + 0.00008 * hum1_signal) + hum1 ;
    		//take the average
    		double hum_avg_temp_comp= (hum0_temp_comp + hum1_temp_comp)/2;
    		//only two numbers after the dot
    		hum_avg_temp_comp= Math.floor(hum_avg_temp_comp * 100) / 100;
    		//end of catch the humidity
    		/****************************/
    		
 
    		/**********LUMINANCE**********/
    		//catch the luminance signals from the telosb sensor and convert them into readeble values    		
    		int lum0_signal= Integer.parseInt(retvals.get(9).toString());
    		int lum1_signal= Integer.parseInt(retvals.get(10).toString());
    		double lum0= (2.5 * (lum0_signal / 4096.0) * 6250.0);
    		double lum1= (2.5 * (lum1_signal / 4096.0) * 6250.0);
    		//take the average
    		double lum_avg= (lum0 + lum1)/2;
    		//only two numbers after the dot
    		lum_avg= Math.floor(lum_avg * 100) / 100;
    		//end of catch the luminance
    		/*****************************/
    		
    		
    		/**********PHOTOSENSOR**********/
    		//catch the photosensor signals from the telosb sensor    		
    		int photo0_signal= Integer.parseInt(retvals.get(11).toString());
    		int photo1_signal= Integer.parseInt(retvals.get(12).toString());
    		//take the average
    		double photo_avg= (photo0_signal + photo1_signal)/2;
    		//only two numbers after the dot
    		photo_avg= Math.floor(photo_avg * 100) / 100;
    		//end of catch the photo sensor
    		/*****************************/

      		// post the data to GSN
      		postStreamElement(new Serializable[] { id, version, interval, count, temp_avg, hum_avg, hum_avg_temp_comp, lum_avg, photo_avg }); 
      			
	
	}
	
	
	private boolean checkArray(String fieldName) {
    		String type = fields.get(fieldName);
    		if(type.contains("[]")) 
    			return true;
    		else 
    			return false;
  	}
	
	
	/*************************************************************************************************************/
	// returned varible must have the same structure of xml virtual sensor file and data field variable.
	public DataField [] getOutputFormat ( ) { 
		
		//return collection output --> must have the same structure of xml virtual sensor file and data field variable.
		return collectionOutput;
	}
	/*************************************************************************************************************/	
	
	
	public String getWrapperName(){
		return "TelosbSensorReadingWrapper";
	}
	
	
	public void dispose ( ) {
    		threadCounter--;
  	}
  	
  	
  	 /** Overrides gsn.wrappers.AbstractWrapper.run
   	* Nothing to do, because the values are inserted to GSN whenever packets arrive.
   	*/
  	public void run ( ) {
  	}
  	
  	
  	/**
   	* Can be used by other classes which are extending this class to create elaborated communication such
   	* as send a packet back to the sensor network.
   	* @return
   	*/
  	protected MoteIF getMoteIF() {
    		return moteIF;
  	}
  	
  	
  	public boolean sendToWrapper(String action, String[] paramNames, Object[] paramValues) throws OperationNotSupportedException {
		   try 	{
				//N.B. action is the field name of command-tag into web-input-tag.
				
				System.out.println("*************************");
				System.out.println("Ready to send message...");
				System.out.println(action); 
				
				TelosbSensorReadingMsg tsrMsg= new TelosbSensorReadingMsg();
				
				if (action.equals("change_interval_value")){
					
					
					//it takes the value from the web. Only one parameter for this function.
					System.out.print(paramNames[0]+": ");
					System.out.println(paramValues[0]);	
					
					//to manage interval upload				
					String updatedIntervalString= paramValues[0].toString();
					System.out.print("New Interval: ");
					System.out.println(updatedIntervalString);
					int updatedInterval= Integer.parseInt(updatedIntervalString);
					//	
					
					//to manage version upload
					version=version+1;
					System.out.print("New Version: ");
					System.out.println(version);
					//
					
					//set version and interval in the sample message
					tsrMsg.set_version(version);
    					tsrMsg.set_interval(updatedInterval);
    					
    					//SEND
    					//send the message in broadcast
   					moteIF.send(MoteIF.TOS_BCAST_ADDR, tsrMsg);
   					//
				
				}
				
				if (action.equals("select_web_command")){
					
					//it takes the value from the web. Only one parameter for this function.
					System.out.print(paramNames[0]+": ");
					System.out.println(paramValues[0]);	
					
					//to manage webCommand upload
					String updatedWebCommandLedString= paramValues[0].toString();
					System.out.print("Web Command: ");
					System.out.println(updatedWebCommandLedString);
					int updatedWebCommandLed= Integer.parseInt(updatedWebCommandLedString);
					
					//to understand the mote id (receiver of the message)
					String receiverString=paramValues[1].toString();
					System.out.print("Receiver: ");
					System.out.println(receiverString);
					int receiver= Integer.parseInt(receiverString);
					
					if ((updatedWebCommandLed==1)||(updatedWebCommandLed==2)||(updatedWebCommandLed==3)){ 
						//set webCommand in the sample message
    						tsrMsg.set_webCommandLed(updatedWebCommandLed);
    					}
    					
    					moteIF.send(receiver, tsrMsg);
    						    						
				}
				
    				
    				
    				
   				
				
				System.out.println("...message correctly sended to Serial Forwarder!");
				System.out.println("*************************");
			
				return true;
			} 
			catch ( IOException e ) {
				logger.warn( "OutputStream write error. " , e );
				return false;
			}
  	}
  	
}

